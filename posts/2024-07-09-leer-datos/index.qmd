---
title: "Acceso a Datos"
author: "Miguel Equihua"
date: 9/jul/2024

lang: es
categories: [datos, datos abiertos, API]

image: magnifying-glass-541626_1280.jpg

lightbox: true
---

## Obtención de Datos

Las fuentes de datos, especialmente hoy, pueden ser muy variadas. Desde los datos que conseguimos directamente en campo a partir de mediciones directas o encuestas, hasta los datos que podemos obtener de _fuentes de datos abiertos_. Considero que será de tu interés explorar las distintas formas de interacción que las fuentes de datos implican para nuestros procesos de producción _científica reproducible_.

### Manejo de claves confidenciales

Un tema importante a cuidar es preservar la confidencialidad de claves, **tokens** y otras formas de identificación personal que puede implicar el proceso de acceso a datos en línea. Así que veremos eso como primer asunto. Queda claro que debemos evitar por todos los medios evitar poner esa información en carpetas o código que pueden acabar siendo registradas en Github en nuestro repositorio público. Haberte vacunado con `usethis::git_vaccinate()` ayuda en gran medida, pero desde luego no es remplazo a estar atentos a lo que estamos haciendo. La estrategia de registro de datos confidenciales que te propongo es la biblioteca `keyring`. Esta biblioteca accede al sistema de almacenamiento de credenciales de tu máquina desde _R_. La describen como una **API** _Independiente de la Plataforma_ para acceder al depósito de credenciales del sistema operativo de tu máquina. [Este sitio explica que es una API (Application Programming Interface)](https://aws.amazon.com/es/what-is/api/). Actualmente `keyring` soporta:  **Keychain** en _macOS_, **Credential Store** wn _Windows_, **the Secret Service API** en _Linux_, soluciones simples (sin plataforma específica) desarrollados con variables de sistema o archivos encristalados e incluso ofrece la posibilidad de desarrollar algunas soluciones propias con sencillez. En nuestro caso, básicamente usaremos dos funciones de esta biblioteca. Primero y desde la pantalla de **Consola** ejecuta:
\

```r
key_set(service = "[dale un nombre]", username = "[el que desees]")
```
\

Esto hará el registro de tus credenciales en tu máquina, fuera de la vista. A partir de ese momento y mientras no elimines el registro explícitamente, estarán disponibles los datos que hayas registrado y los podrás obtener con: 
\

```r
key_ger(service = "[dale un nombre]", username = "[el que desees]")

```
\

Esta última línea recupera los datos confidenciales, así que deberás cuidar usar las credenciales de inmediato y procurar no guardarlas y menos desplegarlas o habilitar medios para mostrarlas, durante el proceso.

Veamos un primer ejemplo con **INEGI**. Te sugiero ir a [https://www.inegi.org.mx/servicios/api_indicadores.html](https://www.inegi.org.mx/servicios/api_indicadores.html), en donde **INEGI** nos muestra un ejemplo de como acceder a los datos abiertos que _compilan_, _mantienen_ y _custodian_. Deberás obtener un **token** personal, el mismo sitio de **INEGI** te dirá como obtenerlo. El ejemplo muestra como obtener datos de la **serie histórica** del indicador de la **Población total** de los Estados Unidos Mexicanos, en idioma español, en formato _JSON_. Una vez que los obtengamos mostraremos los datos en tablas y gráficas.

Lo primero que haremos es preparar el acceso a los datos con el **token** confidencial y obtenemos los datos, sin haber registrado la _URL_ de acceso, pues como viste arriba, incluye tu **token**, así que habrá que manejarla con seguridad. El resultado de este _código_ es una estruuctra de datos que ya no contiene información confidencial.

```{r}
library(httr)
library(jsonlite)
library(rjson)
library(keyring)
library(stringr)
library(flextable)

suppressWarnings(suppressMessages(library(tidyverse)))

# Llamado al API de INEGI
url <-"https://www.inegi.org.mx/app/api/indicadores/desarrolladores/jsonxml/INDICATOR/1002000001/es/00000/false/BISE/2.0/[Aquí va tu Token]?type=json"

# Obtiene los datos (usa los datos confidenciales sin mostrarlos ni guardarlos)
datosGenerales <- content(GET(str_replace(url,
                                          "\\[Aquí va tu Token\\]",
                                          key_get(service = "inegi_api",
                                                  username = "miguel_inegi")))
                          , "text")

```


La siguiente tarea que haremos ahora es simplemente arreglar los datos y ponerlos de la manera que requiero. Los datos son actualmente una base de datos _JSON_, que es una estructura parecida a un diccionario jerárquico, que tiene una etiqueta seguida de los datos que le corresponden. Aquí te muestro un fragmento de los datos de **INEGI** que obtuvimos. Es la sección etiquetada como _Header_. Podemos ver que esta etiqueta tiene como contenido los datos _Name_ y _email_, a su vez con sus respectivos datos.


```{r}
descrip <- fromJSON(datosGenerales[[1]])$Header
prettify(toJSON(descrip))
```

\

Ahora haremos algunas operaciones para arreglar los datos del _JSON_ en una tabla de tipo _data.frame_ (_tibble_ si optamos por una variante actual) en _R_. Los datos que nos interesan son los que están en la etiqueta _Series_ y dentro de estas _Series_ están las listas de _OBSERVATIONS_, que en este caso son 15.

```{r}
#| label: json-txt

# junta todo en un gran texto corrido
flujoDatos <- paste(datosGenerales, collapse = " ") 

# Obtiene la lista de observaciones 
flujoDatos <- fromJSON(flujoDatos) # Convierte al JSON a una lista de R
flujoDatos <- flujoDatos$Series # Toma la sublista Series 
flujoDatos <- flujoDatos[[1]]["OBSERVATIONS"]

cat("\nNúmero de observaciones: ", length(flujoDatos[[1]]),
    "\n\nDatos en cada observación:\n",
    paste("   ", names(flujoDatos[[1]][[1]]), collapse = "\n"), sep = "")

```

Ahora convierto lista de listas en un tabla con los datos de población y año de censado.

```{r}


df1 <- flujoDatos[[1]] %>% 
      sapply(., c) %>% 
      t() %>% 
      as_tibble() %>% 
      select(TIME_PERIOD, OBS_VALUE) %>% 
      mutate(TIME_PERIOD = as.integer(TIME_PERIOD),
             OBS_VALUE = as.integer(OBS_VALUE))


df1 %>% flextable() %>% 
        colformat_int(j = 1, big.mark = "") %>% 
        set_header_labels(TIME_PERIOD = "Año", OBS_VALUE = "Población")

```

Ahora podemos ver los datos como una gráfica

```{r}

plot(df1, type = "b")

```

Ahora con la biblioteca `ggplot2`

```{r}
library(ggplot2)

ggplot(df1, aes(x = TIME_PERIOD, y = OBS_VALUE / 1000000)) +
  geom_point(color = "red", size = 3, show.legend = FALSE) +
  geom_line(color = "blue", show.legend = FALSE) +
  ylab("Población (millones de habitantes)") +
  xlab("Año")

```

